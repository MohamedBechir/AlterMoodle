<p>&nbsp;</p><p>&lt;!-- $Id: html-essay.html,v 1.2 1994/02/15 20:07:12 connolly Exp $ --&gt;</p><p>&lt;html&gt;</p><p>&lt;head&gt;</p><p>&lt;title&gt;Toward a Formalism for Communication On the Web&lt;/title&gt;</p><p>&lt;/head&gt;</p><p>&lt;body&gt;</p><p>&nbsp;</p><p>&lt;ADDRESS&gt;Daniel W. Connolly &lt;connolly@hal.com&gt; &lt;P&gt;</p><p>$Id: html-essay.html,v 1.2 1994/02/15 20:07:12 connolly Exp $</p><p>&lt;/ADDRESS&gt;</p><p>&nbsp;</p><p>&lt;H2&gt;Status&lt;/H2&gt;</p><p>&nbsp;</p><p>&lt;P&gt;I had hoped to polish this more before publishing it, but I can't seem</p><p>to get caught up... there's so much new stuff all the time!</p><p>&nbsp;</p><p>&lt;H1&gt;Some Background on SGML for the World-Wide Web</p><p>&lt;/H1&gt;</p><p>&nbsp;</p><p>&lt;p&gt;In late 1992 and early 1993, I did quite a bit of work on the HTML DTD</p><p>while I was working at Convex in the online documentation group.</p><p>&nbsp;</p><p>&lt;p&gt;When I began, there was the LineMode browser and the NeXT</p><p>implementation, and a few nodes in The Web describing HTML with some</p><p>oblique references to SGML. I was not intimately familiar with SGML, but</p><p>I was quite familiar with the problems of document interchange, and I</p><p>was eager to apply some of my formal systems background to the problem.</p><p>&nbsp;</p><p>&lt;H2&gt;On Formally Unconvertable Document Formats</p><p>&lt;/H2&gt;</p><p>&nbsp;</p><p>&lt;P&gt;My experience with document interchange led me to classify document</p><p>formats using the essential distinction that some are "programmable" and</p><p>some are not. Most widely used source forms are programmable: TeX,</p><p>troff, postscript, and the like. On the other hand, there are several "static"</p><p>formats: plain text, Microsoft RTF, FrameMaker MIF, GNU's TeXinfo,</p><p>&nbsp;</p><p>&lt;P&gt;The reason that this distinction is essential with respect to document</p><p>interchange is that extracting information from documents in</p><p>"programmable" document formats is equivalent to the halting problem.</p><p>That is, it is arbitrarily difficult and cannot be automated in a</p><p>general fashion.</p><p>&nbsp;</p><p>&lt;P&gt;For example, I conjecture that it is impossible to write a program that</p><p>will extract the third word from a TeX document. It would be an easy</p><p>task for 80% of the TeX documents out there -- just skip over some</p><p>formatting stuff and grab the third bunch of characters surrounded by</p><p>whitespace. But that "formatting stuff" might be a program that</p><p>generates 100 words from the hypenation dictionary. So the simple</p><p>lexical scan of the TeX source would find a word that is &lt;em&gt;not&lt;/em&gt; third</p><p>word of the document when printed.</p><p>&nbsp;</p><p>&lt;P&gt;This may seem like an obscure and unimportant problem, but I assure you</p><p>that the problem of converting TeX tables to FrameMaker MIF is just as</p><p>unsolvable.</p><p>&nbsp;</p><p>&lt;P&gt;So while "programmable" document formats have the advantage that</p><p>features can be added on a per-document basis, they suffer the</p><p>disadvantage that these features cannot be recovered by the machine and</p><p>translated in an automated fashion.</p><p>&nbsp;</p><p>&nbsp;</p><p>&lt;H2&gt;Document Formats as Communications Media</p><p>&lt;/H2&gt;</p><p>&nbsp;</p><p>&lt;P&gt;If we look at document formats in light of the conventional</p><p>sender/message/medium/receiver communications model, we see that</p><p>document formats capture the message at various levels of</p><p>"concreteness".</p><p>&nbsp;</p><p>&lt;P&gt;The message begins as a collection of concepts and ideas in the mind of</p><p>the sender. In order to communicate, the sender and receiver must share</p><p>some language. That is, they must both understand some common set of</p><p>symbols and the way those symbols combine to represent ideas. The</p><p>senders job is to express the message in terms of the common symbols and</p><p>express them on the medium -- that is "render" or "present" them. The</p><p>the medium stimulates the receiver to reconstruct the symbols in his/her</p><p>brain -- that is, the receiver "interprets" or "recognizes" the symbols</p><p>from the medium. Those symbols interact with other symbols in the</p><p>receiver's brain, and the receiver "gets the message."</p><p>&nbsp;</p><p>&lt;P&gt;The communications medium is often a layered combination of more and</p><p>less concrete media. For example, folks first render their ideas in the</p><p>symbology of the English language, and then render those symbols as</p><p>sequences of spoken phonemes or written characters. Those written</p><p>characters are in turn combinations of lines, curves, strokes, and</p><p>points. The receiving folks then assemble the strokes into characters,</p><p>the characters into words, the words into phrases, sentences, thoughts,</p><p>ideas, and so on.</p><p>&nbsp;</p><p>&lt;P&gt;The most common and ubiquitous document format, plain ASCII text,</p><p>captures or digitizes messages at the level of written characters.</p><p>PostScript captures the characters as lines, curves, and paths. The GIF</p><p>format captures a document as an array of pixels. GIF is in many ways</p><p>infinitely more expressive than plain text, which is limited to</p><p>arrangements of the 96 ASCII characters.</p><p>&nbsp;</p><p>&lt;P&gt;The RTF, TeX, nroff, etc. document formats provide very sophisticated</p><p>automated techniques for authors of documents to express their ideas. It</p><p>seems strange at first to see that plain text is still so widely used.</p><p>It would seem that PostScript is the ultimate document format, in that</p><p>its expressive capabilities include essentially anything that the human</p><p>eye is capable of perceiving, and yet it is device-independent.</p><p>&nbsp;</p><p>&lt;P&gt;And yet if we take a look at the task of interpreting data back into</p><p>the ideas that they represent, we find that plain text is much to be</p><p>preferred, since reading plain text is so much easier to automate than</p><p>reading GIF files (optical character recognition) or postscript</p><p>documents (halting problem). In the end, while the source to a various</p><p>TeX or troff documents may correspond closely to the structure of the</p><p>ideas of the author, and while PostScript allows the author very precise</p><p>control and tremenous expressive capability, all these documents</p><p>ultimately capture an image of a document for presentation to the human</p><p>eye. They don't capture the original information as symbols that can be</p><p>processed by machine.</p><p>&nbsp;</p><p>&lt;P&gt;To put it another way, rendering ideas in PostScript is not going to</p><p>help solve the problem of information overload -- it will only compound</p><p>the situation.</p><p>&nbsp;</p><p>&lt;P&gt;As a real world example, suppose you had a 5000 page document in</p><p>PostScript, and you wanted to find a particular piece of information</p><p>inside it. The author may have organized the document very well, but</p><p>you'd have to print it to use those clues. If the characters aren't</p><p>kerned much, you might be able to use grep or sick a WAIS indexing</p><p>engine on it. Then, once you've found what looks like postscript code</p><p>for some relavent information, you'd pray that the document adheres to</p><p>the Adobe Document Structuring conventions so that you could pick out</p><p>the page containing the information you need and view that page.</p><p>&nbsp;</p><p>&lt;P&gt;If that's too perverse, look at the problem of navigating a large</p><p>collection of technical papers coded in TeX. Many of the authors use</p><p>LaTeX, and you may be able to convince the indexing engine to filter</p><p>out common LaTeX formatting idioms -- or better yet, weight headings,</p><p>abstracts, etc. more heavily than other sections based on the</p><p>formatting idioms. While there are heuristic solutions to this problem</p><p>that will work in the typical 80%/20% fashion, the general solution is</p><p>once again equivalent to the halting problem; for example, individual</p><p>documents might have bits of TeX programming that change the</p><p>significance of words in a way that the indexing engine won't be able</p><p>to understand.</p><p>&nbsp;</p><p>&nbsp;</p><p>&lt;H2&gt;SGML as a Layered Communications Medium</p><p>&lt;/H2&gt;</p><p>&nbsp;</p><p>&lt;P&gt;So where does SGML fit into the sender/message/medium/receiver game?</p><p>&nbsp;</p><p>&lt;P&gt;I'll use PostScript as a basis of comparison. The PostScript model</p><p>consists of a fairly powerful and general purpose two dimensional</p><p>imaging model, that is, a set of primitive symbols for specifying sets</p><p>of points in two dimensions using handy computational techniques, and a</p><p>general purpose programming model for building complex symbols out of</p><p>those primitives. That model is applied extensively to the problem of</p><p>typography, and there is a an architecture (that is, a set of well known</p><p>symbols derived from the primitives) for using and building fonts.</p><p>&nbsp;</p><p>&lt;P&gt;So to communicate message consisting of symbols from human</p><p>communications in PostScript, one may choose from a well known set of</p><p>typefaces, or create a new typeface using the well known font</p><p>architecture, or free-hand draw some characters using postscript</p><p>primitives, or draw lines, boxes, circles and such using postscript</p><p>primitives, or scribble on a piece of paper, scan it, and convert the</p><p>bits to use the postscript image operator. The space of symbols is</p><p>nearly limitless, as long as those symbols can be expressed ultimately</p><p>as pixels on a page.</p><p>&nbsp;</p><p>&lt;P&gt;The distinctive feature of PostScript (an advantage at times, and a</p><p>disadvantage at others) is that whether you print it and deliver the</p><p>paper or you deliver the PostScript and the receiver prints it out, the</p><p>result is the same bunch of images.</p><p>&nbsp;</p><p>&lt;P&gt;The SGML model, on the other hand, specifies no general purpose</p><p>programming model where complex symbols can be defined in terms of</p><p>primitive symbols. The meaning of a symbol is either found in the SGML</p><p>standard itself, or in some PUBLIC document (which may or may not be</p><p>machine readable), or in some SYSTEM specific manner, or defined by an</p><p>SGML application. The only real primitives are the character and the</p><p>"non-SGML data entity".</p><p>&nbsp;</p><p>&lt;P&gt;The model perscribes that a document consist of a declaration, a</p><p>prologue, and an instance. The declaration is expressed in ASCII and</p><p>specifies the character sets and syntactic symbols used by the prologue</p><p>and instance. The prologue is expressed in a standard language using the</p><p>syntactic symbols from the delcaration, and specifies a set of entities</p><p>and a grammar of element types available to the instance.</p><p>&nbsp;</p><p>&lt;P&gt;The instance is a sequence of elements, character data, and entities</p><p>constrained by the grammar set forth in the prologue, and the SGML</p><p>standard does not specify any semantics or meaning for the instance.</p><p>&nbsp;</p><p>&lt;P&gt;So to communicate using SGML, the sender first chooses a character set</p><p>and certain processing quatities and capacities. For example "I'm</p><p>writing in ASCII, and I'll never use an element name more than 40</p><p>characters long" is some information that can be expressed in the SGML</p><p>declaration. [The standard allows the SGML declaration to be implicitly</p><p>agreed upon by sender and receiver, and this is generally the case].</p><p>&nbsp;</p><p>&lt;P&gt;The tricky part is the prologue, where the sender gives a grammar that</p><p>constrains the structure of the document. Along with the information</p><p>actually expressed in SGML in the prologue, there is usually some amound</p><p>of application defined semantics attached to the element types. For</p><p>example, the prologue may express in SGML that an H2 element must occur</p><p>within the content of an H1 element. But the convention that text in an</p><p>H1 is usually displayed larger and considered more important is</p><p>application defined.</p><p>&nbsp;</p><p>&lt;P&gt;Once the prologue is determined (this usually involves considerable</p><p>discussion between a collection of authors and consumers in some</p><p>domain -- in the end, there may be some "parameter entities" in the</p><p>prologue which allow some variation on a per-document basis), the sender</p><p>is constrained to a rigorous structure for the organization of the</p><p>symbols and character data of the document. On the other hand, s/he has</p><p>an automated technique for verifying that s/he has not viloated the</p><p>structure, and hence there is some confidence that the document can be</p><p>consumed and processed by machine.</p><p>&nbsp;</p><p>&nbsp;</p><p>&lt;H1&gt;The HTML DTD: Conforming, though Expedient</p><p>&lt;/H1&gt;</p><p>&nbsp;</p><p>&lt;H2&gt;Design Constraints of the HTML DTD</p><p>&lt;/H2&gt;</p><p>&nbsp;</p><p>&lt;P&gt;Tim's original conception of HTML is that it should be about as</p><p>expressive as RTF. In contrast to traditional SGML applications where</p><p>documents might be batch processed and complex structure is the norm,</p><p>HTML documents are intended to be processed interactively. And the</p><p>widespread success of WYSIWYG word processors based on fairly flat</p><p>paragraph structure was proof that something like RTF was suitable for a</p><p>fairly wide variety of tasks.</p><p>&nbsp;</p><p>&lt;P&gt;As I learned a little about SGML, it was clear that the WWW browser</p><p>implementation of HTML sorely lacked anything resembling an SGML entity</p><p>manager. And there were some syntactic inconsitencies with the SGML</p><p>standard. And it didn't use the ID/IDREF feature where it should have...</p><p>&nbsp;</p><p>&lt;P&gt;Then, as I began to comprehend SGML with all its warts, (who's idea was</p><p>it to attach the significance of a newline character to the phase of the</p><p>moon anyway?) I was less gung-ho about declaring all the HTML out there</p><p>to be blasphemy to the One True SGML Way.</p><p>&nbsp;</p><p>&lt;P&gt;Thus I chose for my battle to find some formal relationship between the</p><p>SGML standard and the &nbsp;HTML that was "out there." The quest was:</p><p>&nbsp;</p><p>&lt;H3&gt;Find some DTD such that the vast majority of HTML documents are</p><p>instances of that DTD, conversely, such that all its instances make</p><p>sense to the existing WWW clients.</p><p>&lt;/H3&gt;</p><p>&nbsp;</p><p>&lt;P&gt;I struggled mightily with such issues as:</p><p>&nbsp;</p><p>&lt;UL&gt;</p><p>&lt;LI&gt;Should we be sticking &lt;! DOCTYPE HTML SYSTEM&gt; in .html files? What</p><p>if somebody puts an entity declaration in there? (And does that mean</p><p>that WWW clients have to be able to parse SGML prologues in general?</p><p>&nbsp;</p><p>&lt;LI&gt;What's the syntax of an attribute value? If we allow SHORTTAG YES,</p><p>does that mean we have to parse &lt;CODE&gt;&lt;em/this/&lt;/CODE&gt; style of</p><p>markup too?</p><p>&nbsp;</p><p>&lt;LI&gt;Can we put some short reference maps in the DTD that will cause real</p><p>SGML parsers and current WWW browsers to do the same thing w.r.t</p><p>newlines? (i.e. can we make all that phase-of-the-moon processing with</p><p>newlines a moot issue)</p><p>&nbsp;</p><p>&lt;LI&gt;What about marked sections? Short reference maps?</p><p>&nbsp;</p><p>&lt;LI&gt;What character set should we be using? How do I express ISO-Latin-1</p><p>in the SGML declaration? How should authors express the '&lt;' character?</p><p>How should this be expressed in the DTD?</p><p>&nbsp;</p><p>&lt;LI&gt;How do you put quotes in an attribute value literal?</p><p>&nbsp;</p><p>&lt;LI&gt;How can I deal with the current paragraph element idioms without</p><p>using minimization?</p><p>&nbsp;</p><p>&lt;LI&gt;Can I stick base64 encoded stuff in a CDATA element? Do I have to</p><p>watch out for &lt;'s and such?</p><p>&nbsp;</p><p>&lt;LI&gt;How do we combine SGML and multimedia data in the same data stream?</p><p>&nbsp;</p><p>&lt;/UL&gt;</p><p>&nbsp;</p><p>&nbsp;</p><p>&lt;P&gt;I found solutions to some problems, and punted on others. I probably</p><p>should have put more comments in the DTD regarding the compromises. But</p><p>I wanted to keep the DTD stripped down to the normative information and</p><p>keep the informative information in other documents.</p><p>&nbsp;</p><p>&lt;P&gt;I did, by the way, draft a series of 4 or 5 documents demonstrating</p><p>various structural and syntactic features of SGML -- a sort of</p><p>validation suite. I'm not sure where it went.</p><p>&nbsp;</p><p>&lt;P&gt;I'd like to respond to Elliot Kimber's critique of the HTML DTD that I</p><p>posted.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;At the bottom of this posting is a slightly modified copy of the</p><p>&gt;HTML DTD that conforms to the HyTime standard. &nbsp;I have not modified</p><p>&gt;the elements or content models in any way. &nbsp;I have not added any</p><p>&gt;new elements. &nbsp;I have only added to the attribute lists of a few</p><p>&gt;elements.</p><p>&gt;</p><p>&gt;The biggest change I made was to the way URL addresses are handled.</p><p>&gt;In order to use HyTime (as opposed to application-specific)</p><p>&gt;methods for doing addressing, I had to change the URL address</p><p>&gt;from a direct reference into an entity reference where the</p><p>&gt;entity's system identifier is its URL address.</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;I suggested this long ago, but Tim shot the idea down. As I recall, he</p><p>said that all that extra markup was a waste. On the one hand, I agree</p><p>with him -- the purpose of a language is to be able to express common</p><p>idioms succinctly, and SGML/HyTime are poor in that respect. On the</p><p>other hand, once you've chosen SGML, you might as do as the Romans do.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt; &nbsp;This makes</p><p>&gt;the link elements conform to the architectural forms and puts</p><p>&gt;in enough indirection to allow other addressing methods to</p><p>&gt;be used to locate the objects without having to modify the</p><p>&gt;links, only the entity declarations.</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;Why is it easier to modify entity declarations than links? Six of one,</p><p>half-dozen of the other if you ask me.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt; &nbsp;I use SUBDOC entities</p><p>&gt;for refering to other complete documents, although I'm not</p><p>&gt;sure this the best thing, but there's no other construct in</p><p>&gt;SGML that works as well. &nbsp;Note that nowwhere in 8879 does it</p><p>&gt;define what must happen as the result of a SUBDOC reference,</p><p>&gt;except that a new parsing context is established. &nbsp;The actual</p><p>&gt;result of a SUBDOC reference is a matter of style and presumably</p><p>&gt;in a WWW context it would result in the retrieval of the document</p><p>&gt;and its presentation in a seperate window. &nbsp;The key is that</p><p>&gt;the subdoc reference establishes a specific relationship between</p><p>&gt;the source of the link and the target, namely one document</p><p>&gt;refering to another. &nbsp;The target document could also be defined</p><p>&gt;as a data entity with whatever notation is appropriate (possibly</p><p>&gt;even SGML if it's another SGML document). &nbsp;This may be the better</p><p>&gt;approach, I don't know.</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;I don't expect that the data entity/subdocument entity distinction</p><p>matters one hill of beans to contemporary WWW clients. I'm interested to</p><p>know if it means anything to HyTime engines.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;If I were re-designing the HTML, I would add direct support</p><p>&gt;for HyTime location ladders using at a minimum the nameloc,</p><p>&gt;notloc, and dataloc addressing elements. &nbsp;However, if these</p><p>&gt;elements are needed for interchange they could be generated</p><p>&gt;from the information contained in WWW documents using the</p><p>&gt;DTD below, so it's not critical.</p><p>&gt;</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;Could you expand on that? If we'll be "generating" compliant SGML for</p><p>interchange, we might as well use TeXinfo or something practical like</p><p>that for application-specific purposes.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;This is just one attempt at applying HyTime to the HTML.</p><p>&gt;I'm sure there are other equally-valid (or more valid)</p><p>&gt;ways it could be done. &nbsp;Given the current functionality</p><p>&gt;of the WWW, I'm sure there are ways to express that functionality</p><p>&gt;using HyTime constructs. &nbsp;HyTime constructs may also suggest</p><p>&gt;useful ways to extend the WWW functionality, who knows.</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;I finally got to actually read the HyTime standard the other day, and &nbsp;</p><p>the clink and noteloc forms looked most useful. I'm also interested in</p><p>expressing some of the "relative link" idioms used in HTML.</p><p>(e.g how would we express HREF="../foo/bar.html#zabc" using HyTime? The</p><p>object of the game is to do it in such a way that the markup can be</p><p>copied verbatim from one system to another (say unix to VMS) and have</p><p>the right meaning)</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;&lt;!ENTITY % URL "CDATA"</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;-- The term URL means a CDATA attribute</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; whose value is a Universal Resource Locator,</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as defined in ftp://info.cern.ch/pub/www/doc/url3.txt</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;--&gt;</p><p>&gt;&lt;!--=====================================================================</p><p>&gt; &nbsp; &nbsp;WEK: &nbsp;I have defined URL addresses as a notation so that they can</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be then used in a notloc element.</p><p>&gt; &nbsp; &nbsp;=====================================================================--&gt;</p><p>&gt;&lt;!NOTATION url PUBLIC "-//WWW//NOTATION URL/Universal Resource Locator</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /'ftp: info.cern.ch/pub/www/doc/url3.txt'</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //EN"</p><p>&gt;&gt;</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;Cool good idea.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;</p><p>&gt;&lt;!ENTITY % linkattributes</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;"NAME NMTOKEN #IMPLIED</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;HREF ENTITY #IMPLIED</p><p>&gt;</p><p>&gt; --=== WEK =======================================================</p><p>&gt;</p><p>&gt; &nbsp; &nbsp; &nbsp;HREF is now an entity attribute rather than containing a</p><p>&gt; &nbsp; &nbsp; &nbsp;URL address directly. &nbsp;To create a link using a URL address,</p><p>&gt; &nbsp; &nbsp; &nbsp;declare a SUBDOC or data entity and make the system</p><p>&gt; &nbsp; &nbsp; &nbsp;identifier the URL address of the object:</p><p>&gt;</p><p>&gt; &nbsp; &nbsp; &nbsp;&lt;!ENTITY &nbsp;mydoc SYSTEM "URL address of document " SUBDOC &gt;</p><p>&gt;</p><p>&gt; &nbsp; &nbsp; &nbsp;This indirection gives to things:</p><p>&gt;</p><p>&gt; &nbsp; &nbsp; &nbsp;1. A way to protect links in the source from changes in the</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; location of a document since the physical address is only</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; specified once.</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;Ah... now I get it... in case you have lots of links to mydoc or parts</p><p>of mydoc, you only have one place that defines where mydoc is. Nifty.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;</p><p>&gt; &nbsp; &nbsp; &nbsp;2. An opportunity to use other addressing methods, including</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; possibly replacing the URL with an ISO formal public</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; identifier.</p><p>&gt; &nbsp; &nbsp;=================================================================--&gt;</p><p>&gt;</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;TYPE NAME #IMPLIED -- type of relashionship to referent data:</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PARENT CHILD, SIBLING, NEXT, TOP,</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEFINITION, UPDATE, ORIGINAL etc. --</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;URN CDATA #IMPLIED -- universal resource number. unique doc id --</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;TITLE CDATA #IMPLIED -- advisory only --</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;METHODS NAMES #IMPLIED -- supported methods of the object:</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TEXTSEARCH, GET, HEAD, ... --</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;-- WEK: --</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;LINKENDS &nbsp;NAMES #IMPLIED</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- Linkends takes one or more NAME= values for local links--</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;HyNames &nbsp;CDATA #FIXED 'TYPE ANCHROLE URN DOCORSUB'</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;"&gt;</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>&lt;P&gt;I thought the ANCHROLEs of a clink were defined by HyTime to be</p><p>REFsomething and REFSUB. Or are those just defaults? Also... does the</p><p>HyNames think work locally like this? What a HACK!</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;</p><p>&gt;&lt;!--=== WEK ==========================</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;The HyNames= attribute maps the local attribute names to their</p><p>&gt; &nbsp; &nbsp;cooresponding HyTime forms.</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;The Methods= attribute is bit of a puzzle since it is really</p><p>&gt; &nbsp; &nbsp;a part of the hyperlink presentation/processing style, not</p><p>&gt; &nbsp; &nbsp;a property of the anchors, but there's nothing wrong with</p><p>&gt; &nbsp; &nbsp;having application-specific stuff in your HyTime application.</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>The Methods= attribute has been striken :-(. It was motivated by the</p><p>observation that textsearch interactions in WWW go like this:</p><p>&nbsp;</p><p>&lt;OL&gt;</p><p>&lt;LI&gt;Doc A says "click here[23] to see the index"</p><p>&lt;LI&gt;user clicks</p><p>&lt;LI&gt;client fetches link 23, "http://host/index"</p><p>&lt;LI&gt;displays "cover page" document</p><p>&lt;LI&gt;user enters FIND abc</p><p>&lt;LI&gt;client fetches "http://host/index?abc"</p><p>&lt;LI&gt;search results are displayed</p><p>&lt;/OL&gt;</p><p>&nbsp;</p><p>Wheras in gopher, you get to save a step if you like:</p><p>&nbsp;</p><p>&lt;OL&gt;</p><p>&lt;LI&gt;Doc A says "click here[23] to search the index"</p><p>&lt;LI&gt;user clicks</p><p>&lt;LI&gt;client displayes "enter search words here: " dialog</p><p>&lt;LI&gt;user enters FIND abc</p><p>&lt;LI&gt;client fetches "http://host/index?abc"</p><p>&lt;LI&gt;search results are displayed</p><p>&lt;/OL&gt;</p><p>&nbsp;</p><p>So to specify the latter, you would create a link with Methods=textsearch.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt; &nbsp; &nbsp;I added LinkEnds= so that the various linking elements will</p><p>&gt; &nbsp; &nbsp;completely conform to the clink and ilink forms. &nbsp;The presence</p><p>&gt; &nbsp; &nbsp;of the LinkEnds= attribute does not imply required support</p><p>&gt; &nbsp; &nbsp;for this type of linking, but it does make HTML more consistent</p><p>&gt; &nbsp; &nbsp;with other DTDs that do use the LinkEnds= attribute form.</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;Note that 10744 shows the attribute name for the ILINK form</p><p>&gt; &nbsp; &nbsp;to be 'linkend', not 'linkends'. &nbsp;I consider this to be a</p><p>&gt; &nbsp; &nbsp;typo, as there's no logical reason to disallow multiple anchors</p><p>&gt; &nbsp; &nbsp;from a clink and lack of it puts an undue requirement of</p><p>&gt; &nbsp; &nbsp;specifying otherwise unneeded nameloc elements. &nbsp;In any case,</p><p>&gt; &nbsp; &nbsp;an application can transform linkends= to linkend= plus a</p><p>&gt; &nbsp; &nbsp;nameloc, so it doesn't matter in practice.</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>Are there &lt;EM&gt;any&lt;/EM&gt; HyTime implementations out there? Do they use</p><p>'linkend' or 'linkends'? It's hard to beleive that HyTime became a</p><p>standard without a proof-of-concept implementation.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;</p><p>&gt;&lt;!ELEMENT P &nbsp; &nbsp; - O EMPTY -- separates paragraphs --&gt;</p><p>&gt;&lt;!--=== WEK ==========================================================</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;Design note: &nbsp;This seems like a clumsy way to structure information.</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;One would expect paragraphs to be containing.</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;==================================================================--&gt;</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>Yeah, well, try implementing end tag inference in &lt;1000 or so lines of code.</p><p>Maybe we'll get it right next time...</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;&lt;!ELEMENT DL &nbsp; &nbsp;- - &nbsp;(DT | DD | P | %hypertext;)*&gt;</p><p>&gt;&lt;!-- &nbsp; &nbsp;Content should match ((DT,(%hypertext;)+)+,(DD,(%hypertext;)+))</p><p>&gt; &nbsp; &nbsp; &nbsp; &nbsp;But mixed content is messy.</p><p>&gt; &nbsp;--&gt;</p><p>&gt;&lt;!--=== WEK ============================================================</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;Design note: &nbsp;This content should be:</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;&lt;!ELEMENT DL &nbsp;- - (DT+, DD)+ &gt;</p><p>&gt; &nbsp; &nbsp;&lt;!ELEMENT (DT | DD) - O (%hypertext;)* &gt;</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;There's no reason for DT and DD to be empty. &nbsp;Perhaps there was</p><p>&gt; &nbsp; &nbsp;some confusion about the problems with mixed content? &nbsp;There are</p><p>&gt; &nbsp; &nbsp;none here.</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;These comments apply to the other list elements as well.</p><p>&gt;</p><p>&gt; &nbsp; &nbsp;====================================================================--&gt;</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>The problem is that DL, DT, DD, UL, OL, and LI were marked up in extant</p><p>HTML documents as if minimization were supported. But I didn't want to</p><p>introduce minimization into the implementation, so I made the DT, DD,</p><p>and LI elements empty.</p><p>&lt;p&gt;</p><p>&nbsp;</p><p>It's possible I'm confused about mixed content, but the way I understand</p><p>it, you don't want to use mixed content except in repeatable or groups</p><p>because authors will stick whitespace in where it is meant to be ignored</p><p>but it won't be.</p><p>&nbsp;</p><p>&lt;pre&gt;</p><p>&gt;</p><p>&gt;&lt;!-- Character entities omitted. &nbsp;These should be separate from</p><p>&gt; &nbsp; &nbsp; the main DTD so specific applications can define their values.</p><p>&gt; &nbsp; &nbsp; ISO entity sets could be used for this.</p><p>&gt; &nbsp;--&gt;</p><p>&lt;/pre&gt;</p><p>&nbsp;</p><p>Another point I should have explained in the DTD: the WWW application</p><p>specifies that HTML uses the Latin-1 character set, and that the Ouml</p><p>entity represents exactly that character from the Latin-1 character and</p><p>not some system specific thingy. Translation to system character sets is</p><p>done &lt;em&gt;outside&lt;/em&gt; of the SGML parser.</p><p>&nbsp;</p><p>&lt;/body&gt;</p><p>&lt;/html&gt;</p><p>&nbsp;</p>